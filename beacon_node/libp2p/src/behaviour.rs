use crate::rpc::{RPCMethod, RPCRequest, RPCResponse, Rpc, RpcEvent};
use futures::prelude::*;
use libp2p::{
    core::swarm::{NetworkBehaviourAction, NetworkBehaviourEventProcess},
    gossipsub::{Gossipsub, GossipsubConfig, GossipsubEvent},
    tokio_io::{AsyncRead, AsyncWrite},
    NetworkBehaviour, PeerId,
};
use types::Topic;

/// Builds the network behaviour for the libp2p Swarm.
/// Implements gossipsub message routing.
#[derive(NetworkBehaviour)]
#[behaviour(out_event = "BehaviourEvent", poll_method = "poll")]
pub struct Behaviour<TSubstream: AsyncRead + AsyncWrite> {
    gossipsub: Gossipsub<TSubstream>,
    // TODO: Add Kademlia for peer discovery
    /// The events generated by this behaviour to be consumed in the swarm poll.
    serenity_rpc: Rpc<TSubstream>,
    #[behaviour(ignore)]
    events: Vec<BehaviourEvent>,
}

// Implement the NetworkBehaviourEventProcess trait so that we can derive NetworkBehaviour for Behaviour
impl<TSubstream: AsyncRead + AsyncWrite> NetworkBehaviourEventProcess<GossipsubEvent>
    for Behaviour<TSubstream>
{
    fn inject_event(&mut self, event: GossipsubEvent) {
        match event {
            GossipsubEvent::Message(message) => {
                let gs_message = String::from_utf8_lossy(&message.data);
                // TODO: Remove this type - debug only
                self.events
                    .push(BehaviourEvent::Message(gs_message.to_string()))
            }
            _ => {}
        }
    }
}

impl<TSubstream: AsyncRead + AsyncWrite> NetworkBehaviourEventProcess<RpcEvent>
    for Behaviour<TSubstream>
{
    fn inject_event(&mut self, event: RpcEvent) {
        match event {
            RpcEvent::Request {
                id,
                method_id,
                body,
            } => self.events.push(BehaviourEvent::RPCRequest {
                id,
                method: RPCMethod::from(method_id),
                body,
            }),
            RpcEvent::Response {
                id,
                method_id,
                result,
            } => self.events.push(BehaviourEvent::RPCResponse { id, result }),
        }
    }
}

impl<TSubstream: AsyncRead + AsyncWrite> Behaviour<TSubstream> {
    pub fn new(local_peer_id: PeerId, gs_config: GossipsubConfig) -> Self {
        Behaviour {
            gossipsub: Gossipsub::new(local_peer_id, gs_config),
            serenity_rpc: Rpc::new(),
            events: Vec::new(),
        }
    }

    /// Consumes the events list when polled.
    fn poll<TBehaviourIn>(
        &mut self,
    ) -> Async<NetworkBehaviourAction<TBehaviourIn, BehaviourEvent>> {
        if !self.events.is_empty() {
            return Async::Ready(NetworkBehaviourAction::GenerateEvent(self.events.remove(0)));
        }

        Async::NotReady
    }
}

impl<TSubstream: AsyncRead + AsyncWrite> Behaviour<TSubstream> {
    pub fn subscribe(&mut self, topic: Topic) -> bool {
        self.gossipsub.subscribe(topic)
    }

    pub fn send_message(&self, message: String) {
        // TODO: Encode and send via gossipsub

    }
}

/// The types of events than can be obtained from polling the behaviour.
pub enum BehaviourEvent {
    RPCRequest {
        id: u64,
        method: RPCMethod,
        body: RPCRequest,
    },
    RPCResponse {
        id: u64,
        result: RPCResponse,
    },
    // TODO: This is a stub at the moment
    Message(String),
}
